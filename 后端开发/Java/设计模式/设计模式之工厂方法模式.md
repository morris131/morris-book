---
title: 设计模式之工厂方法模式
date: 2018-09-19 17:18:22
categories: 设计模式
tags: [设计模式,工厂方法模式]
---

# 设计模式之工厂方法模式

在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。

## 定义
在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。工厂方法模式定义如下：

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

## 类图
![工厂方法模式类图]()

在工厂方法模式结构图中包含如下几个角色：
- Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
- ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
- Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
- ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。
## 实现
[Product.java](pattern/src/main/java/com/morris/pattern/factroy/Product.java)
```java
package com.morris.pattern.factory;

public interface Product {
}
```
[Factory.java](pattern/src/main/java/com/morris/pattern/factroy/Factory.java)
```java
package com.morris.pattern.factory;

public interface Factory {
    Product createProduct();
}
```
[ConcreteProduct.java](pattern/src/main/java/com/morris/pattern/factroy/ConcreteProduct.java)
```java
package com.morris.pattern.factory;

public class ConcreteProduct implements  Product {
}
```
[ConcreteFactory.java](pattern/src/main/java/com/morris/pattern/factroy/ConcreteFactory.java)
```java
package com.morris.pattern.factory;

public class ConcreteFactory implements Factory {

    @Override
    public Product createProduct() {
        return new ConcreteProduct();
    }

}
```

## 图片读取器实例
场景：设计一个程序来读取各种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器，如 GIF 图片读取器用于读取 GIF 格式的图片、JPG 图片读取器用于读取 JPG 格式的图片。需充分考虑系统的灵活性和可扩展性。

### 采用简单工厂模式设计
[PictureReader.java]()
```java
package com.morris.pattern.factory.demo.v1;

public interface PictureReader {
    void read();
}
```

```java
package com.morris.pattern.factory.demo.v1;

public class GifPictureReader implements  PictureReader {
    @Override
    public void read() {
        System.out.println("GIF读取器");
    }
}
```

```java
package com.morris.pattern.factory.demo.v1;

public class JpgPictureReader implements  PictureReader {
    @Override
    public void read() {
        System.out.println("JPG读取器");
    }
}
```

```java
package com.morris.pattern.factory.demo.v1;

public class PictureReaderFactory {

    public static PictureReader createPictureReader(String type) {
        if("gif".equals(type)) {
            return new GifPictureReader();
        } else if("jpg".equals(type)) {
            return new JpgPictureReader();
        }
        return null;
    }

}

```

虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：
1. 工厂类过于庞大，包含了大量的 if…else… 代码，导致维护和测试难度增大；
2. 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。

### 采用工厂方法模式设计
```java
package com.morris.pattern.factory.demo.v2;

public interface PictureReader {
    void read();
}

```

```java
package com.morris.pattern.factory.demo.v2;

public class GifPictureReader implements PictureReader {
    @Override
    public void read() {
        System.out.println("GIF读取器");
    }
}

```

```java
package com.morris.pattern.factory.demo.v2;

public class JpgPictureReader implements PictureReader {
    @Override
    public void read() {
        System.out.println("JPG读取器");
    }
}

```

```java
package com.morris.pattern.factory.demo.v2;

public interface PictureReaderFactory {
     PictureReader createPictureReader();
}

```

```java
package com.morris.pattern.factory.demo.v2;

public class GifPictureReaderFactory implements PictureReaderFactory {
    @Override
    public PictureReader createPictureReader() {
        return new GifPictureReader();
    }
}

```
```java
package com.morris.pattern.factory.demo.v2;

public class JpgPictureReaderFactory implements PictureReaderFactory {
    @Override
    public PictureReader createPictureReader() {
        return new JpgPictureReader();
    }
}

```

## 优点
- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。
- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

## 缺点
- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。

## 适用场景
首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。

再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。
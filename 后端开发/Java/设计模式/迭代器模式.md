---
title: 迭代器模式
date: 2018-10-30
categories: 设计模式
tags: [设计模式,迭代器模式]
---

# 迭代器模式

## 定义
迭代器模式（Iterator Pattern）：提供一种方法来访问聚合对象，而不用暴露这个对象的内部细节。

## 类图
![迭代器模式类图](https://github.com/morris131/morris-book/raw/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png)

在迭代器模式结构图中包含如下几个角色：

Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的 first() 方法，用于访问下一个元素的 next() 方法，用于判断是否还有下一个元素的 hasNext() 方法，用于获取当前元素的 currentItem() 方法等，在具体迭代器中将实现这些方法。

ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个 createIterator() 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的 createIterator() 方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。
## 实现
[Observer.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/Observer.java)
```java
package com.morris.pattern.observer.impl;

public interface Observer {
    void update();
}
```
[ConcreteObserverA.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/ConcreteObserverA.java)
```java
package com.morris.pattern.observer.impl;

public class ConcreteObserverA implements Observer {
    @Override
    public void update() {
        System.out.println("ConcreteObserverA receive message");
    }
}
```
[ConcreteObserverB.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/ConcreteObserverB.java)

```java
package com.morris.pattern.observer.impl;

public class ConcreteObserverB implements Observer {
    @Override
    public void update() {
        System.out.println("ConcreteObserverB receive message");
    }
}
```
[Subject.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/Subject.java)
```java
package com.morris.pattern.observer.impl;

import java.util.ArrayList;
import java.util.List;

public abstract class Subject {

    private List<Observer> observers = new ArrayList<>();

    protected void attach(Observer observer) {
        observers.add(observer);
    }

    protected void detach(Observer observer) {
        observers.remove(observer);
    }

    protected void notifyObservers() {
        for(Observer observer: observers) {
            observer.update();
        }
    }
}
```
[ConcreteSubject.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/ConcreteSubject.java)
```java
package com.morris.pattern.observer.impl;

public class ConcreteSubject extends Subject {

    public void doSomething() {
        System.out.println("call ConcreteSubject.doSomething()");
        super.notifyObservers();
    }

}
```
[Client.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/observer/impl/Client.java)
```java
package com.morris.pattern.observer.impl;

public class Client {

    public static void main(String[] args) {

        Observer observerA = new ConcreteObserverA();
        Observer observerB = new ConcreteObserverB();

        ConcreteSubject subject = new ConcreteSubject();
        subject.attach(observerA);
        subject.attach(observerB);

        subject.doSomething();

    }
}
```



## 优点
- 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
- 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
- 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

## 缺点
- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

## 适用场景
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。
- 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。
- 需要在系统中创建一个触发链，A 对象的行为将影响B对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制
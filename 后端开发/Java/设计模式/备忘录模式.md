---
title: 备忘录模式
date: 2018-11-01
categories: 备忘录模式
tags: [设计模式,备忘录模式]
---

# 备忘录模式

## 定义
备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

## 类图
![备忘录模式类图](https://github.com/morris131/morris-book/raw/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png)

在迭代器模式类图中包含如下几个角色：
- Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。
- ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
- Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个 createIterator() 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
- ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的 createIterator() 方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。

## 实现
[Iterator.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/iterator/impl/Iterator.java)
```java
package com.morris.pattern.iterator.impl;

public interface Iterator<T> {

    T next();

    boolean hasNext();

}
```
[ConcreteIterator.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/iterator/impl/ConcreteIterator.java)
```java
package com.morris.pattern.iterator.impl;

import java.util.Vector;

public class ConcreteIterator<T> implements Iterator<T> {

    private Vector<T> vector = new Vector<>();

    private int cursor = 0;

    public ConcreteIterator(Vector<T> vector) {
        this.vector = vector;
    }


    @Override
    public T next() {
        return vector.get(cursor++);
    }

    @Override
    public boolean hasNext() {
        return !(cursor == vector.size());
    }

}
```
[Aggregate.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/iterator/impl/Aggregate.java)

```java
package com.morris.pattern.iterator.impl;

public interface Aggregate<T> {

    boolean add(T t);

    Iterator<T> iterator();

}
```
[ConcreteAggregate.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/iterator/impl/ConcreteAggregate.java)
```java
package com.morris.pattern.iterator.impl;

import java.util.Vector;

public class ConcreteAggregate<T> implements Aggregate <T> {

    private Vector<T> vector = new Vector<>();

    @Override
    public boolean add(T t) {
        return vector.add(t);
    }

    @Override
    public Iterator<T> iterator() {
        return new ConcreteIterator<>(vector);
    }
}
```
[Client.java](https://github.com/morris131/morris-book/tree/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pattern/src/main/java/com/morris/pattern/iterator/impl/Client.java)
```java
package com.morris.pattern.iterator.impl;

public class Client {

    public static void main(String[] args) {

        Aggregate<String> aggregate = new ConcreteAggregate<>();
        aggregate.add("a");
        aggregate.add("b");
        aggregate.add("c");
        aggregate.add("d");

        Iterator<String> iterator = aggregate.iterator();

        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

    }
}
```

## 优点
- 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。
- 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。
- 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

## 缺点
- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
- 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如 JDK 内置迭代器 Iterator 就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类 ListIterator 等来实现，而 ListIterator 迭代器无法用于操作 Set 类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。

## 适用场景
- 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。
- 需要为一个聚合对象提供多种遍历方式。
- 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。
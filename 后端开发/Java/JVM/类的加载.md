# 类的加载

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。

类的加载的最终产品是位于堆区中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。加载类的方式有以下几种：

- 从本地系统直接加载
- 通过网络下载.class文件
- 从zip，jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件（服务器）


## 类的加载过程
一个java文件从被加载到被卸载这个生命过程，总共要经历5个阶段，JVM将类加载过程分为： 

![](https://github.com/morris131/morris-book/raw/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/JVM/images/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png)

### 加载
下面是对于加载过程最为官方的描述：
> 加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。

总的来说就是查找并把代码数据加载到内存中。 

### 验证
验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内(Unsupported major.minor version 51.0异常)、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 准备
准备阶段是为类变量在方法区分配内存并设置默认值的阶段。对于该阶段有以下几点需要注意：

1. 此时内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 此处设置的初始值是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
3. 静态常量直接被赋予默认值。

// 例子

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

符号引用就是一组符号来描述目标，可以是任何字面量。

直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化，为类的静态变量赋予正确的初始值，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
 
1. 声明类变量是指定初始值
2. 使用静态代码块为类变量指定初始值

类在以下几种情况下才会被加载和初始化。
1. 创建类的实例，也就是new一个对象 
2. 访问某个类或接口的静态变量，或者对该静态变量赋值 
3. 调用类的静态方法 
4. 反射
5. 初始化一个类的子类（会首先初始化子类的父类）
6. 调用main方法

类的初始化顺序如下：
1. 如果这个类还没有被加载和链接，那先进行加载和链接
2. 假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）
3. 加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。
4. 总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法 

### 使用
当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。

### 卸载
JVM规定了一个Class只有在满足一下三个条件的时候才会被GC回收，也就是类的卸载。
1. 该类所有的实例已经把GC。
2. 该类的Class对象不再被引用，即不可触及。
3. 加载该类的ClassLoader已经被GC。


## 类加载器 

![](https://github.com/morris131/morris-book/raw/master/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/JVM/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png)

### 根类加载器
根类加载器（BootstrapClassLoader）：负责加载存放在JDK\jre\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。根类加载器是无法被Java程序直接引用的。

[BootstrapClassLoaderTest.java]()
```java
package com.morris.jvm.load;

import java.util.Arrays;

public class BootstrapClassLoaderTest {

    public static void main(String[] args) {
        System.out.println("BootstrapClassLoader:" + String.class.getClassLoader());
        Arrays.asList(System.getProperty("sun.boot.class.path").split(";")).stream().forEach(System.out::println);
    }
}
```
运行结果如下所示，其中String.class的类加载器是根类加载器，根类加载器是获取不到引用的，因此输出为null，而根类加载器所加载的jar可以通过系统属性sun.boot.class.path获取。
```
BootstrapClassLoader:null
D:\Program Files\Java\jdk1.8.0_172\jre\lib\resources.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\rt.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\sunrsasign.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jsse.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jce.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\charsets.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jfr.jar
D:\Program Files\Java\jdk1.8.0_172\jre\classes
```

### 扩展类加载器
扩展类加载器（Extension ClassLoader）：扩展类加载器的父加载器是根类加载器，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

```java
package com.morris.jvm.load;

import java.util.Arrays;

public class ExtClassLoaderTest {
    public static void main(String[] args) {
        System.out.println("ExtClassLoader:" + com.sun.nio.zipfs.ZipDirectoryStream.class.getClassLoader());
        System.out.println("ExtClassLoader parent:" + com.sun.nio.zipfs.ZipDirectoryStream.class.getClassLoader().getParent());
        Arrays.asList(System.getProperty("java.ext.dirs").split(";")).stream().forEach(System.out :: println);
    }
}
```

```
ExtClassLoader:sun.misc.Launcher$ExtClassLoader@2503dbd3
ExtClassLoader parent:null
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext
C:\Windows\Sun\Java\lib\ext
```

### 系统类加载器
系统类加载器（Application ClassLoader）：系统类加载器的父加载器是扩展类加载器，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，系统类加载器的加载路径可以通过-classpath来指定，同样也可以通过系统属性java.class.path来获取。

[AppClassLoaderTest.java]()
```java
package com.morris.jvm.load;

import java.util.Arrays;

public class AppClassLoaderTest {

    public static void main(String[] args) {
        System.out.println("AppClassLoader:" +AppClassLoaderTest.class.getClassLoader());
        System.out.println("AppClassLoader parent:" +AppClassLoaderTest.class.getClassLoader().getParent());
        Arrays.asList(System.getProperty("java.class.path").split(";")).stream().forEach(System.out::println);
    }
}
```
idea启动命令如下：
```
"D:\Program Files\Java\jdk1.8.0_172\bin\java.exe" "-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2018.1.4\lib\idea_rt.jar=49316:D:\Program Files\JetBrains\IntelliJ IDEA 2018.1.4\bin" -Dfile.encoding=UTF-8 -classpath "D:\Program Files\Java\jdk1.8.0_172\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_172\jre\lib\rt.jar;D:\gitPrj\morris-book\后端开发\Java\JVM\jvm\target\classes;C:\Users\wj65651\.m2\repository\cglib\cglib\2.2.2\cglib-2.2.2.jar;C:\Users\wj65651\.m2\repository\asm\asm\3.3.1\asm-3.3.1.jar" com.morris.jvm.load.AppClassLoaderTest
```
运行结果如下：
```
AppClassLoader:sun.misc.Launcher$AppClassLoader@18b4aac2
AppClassLoader parent:sun.misc.Launcher$ExtClassLoader@14ae5a5
D:\Program Files\Java\jdk1.8.0_172\jre\lib\charsets.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\deploy.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\access-bridge-64.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\cldrdata.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\dnsns.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\jaccess.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\jfxrt.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\localedata.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\nashorn.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunec.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunjce_provider.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunmscapi.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\sunpkcs11.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\ext\zipfs.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\javaws.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jce.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jfr.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jfxswt.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\jsse.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\management-agent.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\plugin.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\resources.jar
D:\Program Files\Java\jdk1.8.0_172\jre\lib\rt.jar
D:\gitPrj\morris-book\后端开发\Java\JVM\jvm\target\classes
C:\Users\wj65651\.m2\repository\cglib\cglib\2.2.2\cglib-2.2.2.jar
C:\Users\wj65651\.m2\repository\asm\asm\3.3.1\asm-3.3.1.jar
D:\Program Files\JetBrains\IntelliJ IDEA 2018.1.4\lib\idea_rt.jar
```

### 自定义加载器
通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，我们只需要重写 findClass 方法即可。

自定义类加载器MyClassLoader.java
```java
package com.morris.jvm.load;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

// 自定义类加载器必须继承ClassLoader
public class MyClassLoader extends ClassLoader {

    private static final Path DEFAULT_CLASS_DIR = Paths.get("D:","classloader");

    private final Path classDir;

    public MyClassLoader() {
        this.classDir = DEFAULT_CLASS_DIR;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] bytes = this.readByte(name);

        if(null == bytes || 0 == bytes.length) {
            throw new ClassNotFoundException("Can not load the class " + name);
        }

        return this.defineClass(name, bytes, 0, bytes.length);
    }

    // 将class文件读入内存
    private byte[] readByte(String name) throws ClassNotFoundException{
       String classPath = name.replace(".", "/");

        Path classFullPath = this.classDir.resolve(classPath + ".class");

        if(!classFullPath.toFile().exists()) {
            throw new ClassNotFoundException("The class " + name + " not found.");
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try {
            Files.copy(classFullPath, baos);
            return baos.toByteArray();
        } catch (IOException e) {
            throw new ClassNotFoundException("load the class " + name + " error", e);
        }
    }

}
```

下面写一个简单的HelloWorld程序，使用自定义类加载器对其进行加载。
[HelloWorld.java]()
```java
package com.morris.jvm.load;

public class HelloWorld {

    static {
        System.out.println("HelloWorld Class is initialized.");
    }

}
```
将HelloWorld类编译后将class文件复制到D:\classloader\com\morris\jvm\load目录下，同时将class path中的HelloWorld.class删除，如果使用的集成开发环境，则需要将HelloWorld.java一并删除，否则将会由系统类加载器加载。

测试类[MyClassLoaderTest.java]()
```java
package com.morris.jvm.load;

public class MyClassLoaderTest {

    public static void main(String[] args) throws ClassNotFoundException {
        MyClassLoader myClassLoader = new MyClassLoader();
        Class<?> clazz = myClassLoader.loadClass("com.morris.jvm.load.HelloWorld");
        System.out.println(clazz.getClassLoader());
    }
}
```
运行结果如下，虽然HelloWorld类被成功加载并且输出了自定义类加载器的信息，但是HelloWorld类的静态代码块并没有输出，因为使用类加载器的loadClass并不会导致类的主动初始化，只是执行了类加载过程中的加载阶段而已。
```
com.morris.jvm.load.MyClassLoader@7f31245a
```

Class.forName()和ClassLoader.loadClass()区别
- Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
- ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采会调用构造函数，创建类的对象。

## 双亲委托机制
如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。委派的好处就是避免有些类被重复加载。

源码分析如下：

摘自jdk1.8 java.lang.ClassLoader
```
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 检查是否被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 父类加载器不为空，则用父类加载器加载
                        c = parent.loadClass(name, false);
                    } else {
                        // 父类加载器为空，则用根加载器加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    // 父类加载失败，则使用自己的findClass方法进行加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

```

// 画个流程图

## 破坏双亲委托机制

### 设置父类加载器为扩展类加载器
```java
package com.morris.jvm.load;

public class BreakClassLoader1 {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader extClassLoader = BreakClassLoader1.class.getClassLoader().getParent();
        MyClassLoader myClassLoader = new MyClassLoader(extClassLoader); // 设置父类加载器为扩展类加载器
        Class<?> clazz = myClassLoader.loadClass("com.morris.jvm.load.HelloWorld");
        System.out.println(clazz.getClassLoader());
    }
}
```

### 设置父类加载器为null
```java
package com.morris.jvm.load;

public class BreakClassLoader2 {
    public static void main(String[] args) throws ClassNotFoundException {
        MyClassLoader myClassLoader = new MyClassLoader(null); // 设置父类加载器为null
        Class<?> clazz = myClassLoader.loadClass("com.morris.jvm.load.HelloWorld");
        System.out.println(clazz.getClassLoader());
    }
}
```

### 重写父类ClassLoader的loadClass方法
```java
package com.morris.jvm.load;

public class BreakDelegateClassLoader extends MyClassLoader {

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        // 根据类的全限定名进行加锁，确保一个类在多线程下只被加载一次
        synchronized (getClassLoadingLock(name)) {
            // 到已加载类的缓存中查看是否已经加载过，如果已加载则直接返回
            Class<?> c = findLoadedClass(name);
            if (null == c) {

                // 尝试使用自定义类加载器加载
                c = this.findClass(name);

                // 如果自定义加载器无法加载，则委托其父类进行加载
                if(null == c) {
                    try {
                        if (getParent() != null) {
                            c = getParent().loadClass(name);
                        } else {
                            c = getSystemClassLoader().loadClass(name);
                        }
                    } catch (ClassNotFoundException e) {
                    }
                }

            }

            // 经过若干次尝试后仍无法加载，则抛出异常
            if (c == null) {
                throw new ClassNotFoundException("The class " + name + " not found.");
            }

            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
}
```

### 是否可以加载自定义java.lang.String类

在d:\classloader\java\lang 增加String类，并编译为String.class。

测试类
```java
package com.morris.jvm.load;

public class StringClassLoaderTest {

    public static void main(String[] args) throws ClassNotFoundException {
        BreakDelegateClassLoader myClassLoader = new BreakDelegateClassLoader();
        Class<?> clazz = myClassLoader.loadClass("java.lang.String");
        System.out.println(clazz.getClassLoader());
    }
}
```
运行结果如下：
```
Exception in thread "main" java.lang.SecurityException: Prohibited package name: java.lang
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:642)
	at com.morris.jvm.load.MyClassLoader.findClass(MyClassLoader.java:33)
	at com.morris.jvm.load.BreakDelegateClassLoader.loadClass(BreakDelegateClassLoader.java:14)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at com.morris.jvm.load.StringClassLoaderTest.main(StringClassLoaderTest.java:7)
```
JVM出于安全考虑，禁止使用以java开头的包名。以下为相关源码：

摘自jdk1.8 java.lang.ClassLoader
```
    protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                         ProtectionDomain protectionDomain)
        throws ClassFormatError
    {
        protectionDomain = preDefineClass(name, protectionDomain);
        String source = defineClassSourceLocation(protectionDomain);
        Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
        postDefineClass(c, protectionDomain);
        return c;
    }
    
    private ProtectionDomain preDefineClass(String name,
                                            ProtectionDomain pd)
    {
        if (!checkName(name))
            throw new NoClassDefFoundError("IllegalName: " + name);

        // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias
        // relies on the fact that spoofing is impossible if a class has a name
        // of the form "java.*"
        if ((name != null) && name.startsWith("java.")) {
            throw new SecurityException
                ("Prohibited package name: " +
                 name.substring(0, name.lastIndexOf('.')));
        }
        if (pd == null) {
            pd = defaultDomain;
        }

        if (name != null) checkCerts(name, pd.getCodeSource());

        return pd;
    }
```

## 命名空间与运行时包

每个类加载器都有自己的命名空间。同一个命名空间内的类是相互可见的，命名空间由该加载器及所有父加载器所加载的类组成。

子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器的类。例如系统类加载器加载的类能看见根类加载器加载的类。由父亲加载器加载的类不能看见子加载器加载的类。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载类相互不可见。

在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

在类的加载过程中，所有参与的类加载器，即时没有亲自加载过该类，都会被标识为该类的初始类加载器，实际加载类的加载器被称为定义类加载器。

```java
package com.morris.jvm.load;

// 自定义类加载器必须继承ClassLoader
public class CustomerClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        return super.loadClass(name);
    }

}
```

```java
package com.morris.jvm.load;

public class CustomerClassLoaderTest {

    public static void main(String[] args) throws ClassNotFoundException {
        CustomerClassLoader myClassLoader = new CustomerClassLoader();
        Class<?> clazz = myClassLoader.loadClass("java.lang.String");
        System.out.println(clazz.getClassLoader());
    }
}

```

在上面例子中，java.lang.String依次经过了CustomerClassLoader类加载器、系统类加载器、扩展类加载器、根类加载器，这些加载器都是java.lang.String的初始类加载器，而根类加载是java.lang.String的定义类加载器，JVM会在每一个类加载器维护的列表中添加该类型。如下图所示：


### 同一个类加载器实例加载同一个class
```java
package com.morris.jvm.load;

public class NameSpaceTest1 {

    public static void main(String[] args) throws ClassNotFoundException {
        // 获取系统类加载器
        ClassLoader classLoader = NameSpaceTest1.class.getClassLoader();

        Class<?> aClass = classLoader.loadClass("com.morris.jvm.load.HelloWorld");
        Class<?> bClass = classLoader.loadClass("com.morris.jvm.load.HelloWorld");

        System.out.println(aClass == bClass); // true
    }
}
```
使用同一个类加载器实例不论load多少次，都只会返回同一个class对象。

### 不同类加载器加载同一个class
```java
package com.morris.jvm.load;

public class NameSpaceTest2 {

    public static void main(String[] args) throws ClassNotFoundException {
        
        ClassLoader classLoader = new MyClassLoader();
        ClassLoader classLoader2 = new BreakDelegateClassLoader();

        Class<?> aClass = classLoader.loadClass("com.morris.jvm.load.HelloWorld");
        Class<?> bClass = classLoader2.loadClass("com.morris.jvm.load.HelloWorld");

        System.out.println(aClass == bClass); // false
    }
}
```
使用不同的类加载器实例加载同一个class，会在堆内存产生多个class对象。

### 相同类加载器加载同一个class
```java
package com.morris.jvm.load;

public class NameSpaceTest3 {

    public static void main(String[] args) throws ClassNotFoundException {

        ClassLoader classLoader = new MyClassLoader();
        ClassLoader classLoader2 = new MyClassLoader();

        Class<?> aClass = classLoader.loadClass("com.morris.jvm.load.HelloWorld");
        System.out.println(aClass.getClassLoader());
        Class<?> bClass = classLoader2.loadClass("com.morris.jvm.load.HelloWorld");
        System.out.println(bClass.getClassLoader());

        System.out.println(aClass == bClass); // false
    }
}
```
使用相同的类加载器实例加载同一个class，会在堆内存产生多个class对象。

## 线程上下文加载器与SPI


## 热部署


## 面试题

```
package com.morris.jvm.load;

public class StaticTest {

    public static int k = 0;

    public static StaticTest t1 = new StaticTest("t1"); 

    public static StaticTest t2 = new StaticTest("t2"); 

    public static int i = print("i");

    public static int n = 99;

    public int j = print("j");
     
    {
        print("构造块");
    }

    static{
        print("静态块");
    }

    public StaticTest(String str) {
        System.out.println((++k) + ":" + str + " i=" + i + " n=" + n);
        ++n;
        ++i;
    }

    public static int print(String str) {
        System.out.println((++k) + ":" + str + " i=" + i + " n=" + n);
        ++i;
        return ++n;
    }
    
    public static void main(String[] args) {
        new StaticTest("init");
        
    }
 
}
```
运行结果如下：

```
1:j i=0 n=0
2:构造块 i=1 n=1
3:t1 i=2 n=2
4:j i=3 n=3
5:构造块 i=4 n=4
6:t2 i=5 n=5
7:i i=6 n=6
8:静态块 i=7 n=99
9:j i=8 n=100
10:构造块 i=9 n=101
11:init i=10 n=102
```


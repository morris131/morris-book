---
title: 编解码框架分析
date: 2019-04-18
categories: netty
tags: [netty]
---

# 编解码框架分析
编码（Encode）也称为序列化（serialization），它将对象序列化为字节数组，用于网络传输、数据持久化或者其它用途。

反之，解码（Decode）/ 反序列化（deserialization）把从网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的拷贝），以方便后续的业务逻辑操作。

进行远程跨进程服务调用时（例如 RPC 调用），需要使用特定的编解码技术，对需要进行网络传输的对象做编码或者解码，以便完成远程调用。

## 常用的编解码框架
### Java 序列化
Java 默认提供的序列化机制，需要序列化的 Java 对象只需要实现 java.io.Serializable 接口并生成序列化 ID，这个类就能够通过 java.io.ObjectInput 和 java.io.ObjectOutput 序列化和反序列化。

由于使用简单，开发门槛低，Java 序列化得到了广泛的应用，但是由于它自身存在很多缺点，因此大多数的 RPC 框架并没有选择它。Java 序列化的主要缺点如下：

1. 无法跨语言：是 Java 序列化最致命的问题。对于跨进程的服务调用，服务提供者可能会使用 C++ 或者其它语言开发，当我们需要和异构语言进程交互时，Java 序列化就难以胜任。由于 Java 序列化技术是 Java 语言内部的私有协议，其它语言并不支持，对于用户来说它完全是黑盒。Java 序列化后的字节数组，别的语言无法进行反序列化，这就严重阻碍了它的应用范围；
2. 序列化后的码流太大: 例如使用二进制编解码技术对同一个复杂的 POJO 对象进行编码，它的码流仅仅为 Java 序列化之后的 20% 左右；目前主流的编解码框架，序列化之后的码流都远远小于原生的 Java 序列化；
3. 序列化效率差：在相同的硬件条件下、对同一个 POJO 对象做 100W 次序列化，二进制编码和 Java 原生序列化的性能对比测试如下图所示：Java 原生序列化的耗时是二进制编码的 16.2 倍，效率非常差。

### Google 的 Protobuf
Protobuf 全称 Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto 文件进行描述，通过代码生成工具可以生成对应数据结构的 POJO 对象和 Protobuf 相关的方法和属性。

它的特点如下：
1. 结构化数据存储格式（XML，JSON 等）；
2. 高效的编解码性能；
3. 语言无关、平台无关、扩展性好；
4. 官方支持 Java、C++ 和 Python 三种语言。

### JBoss Marshalling
JBoss Marshalling 是一个 Java 对象的序列化 API 包，修正了 JDK 自带的序列化包的很多问题，但又保持跟 java.io.Serializable 接口的兼容；同时增加了一些可调的参数和附加的特性，并且这些参数和特性可通过工厂类进行配置。

相比于传统的 Java 序列化机制，它的优点如下：
1. 可插拔的类解析器，提供更加便捷的类加载定制策略，通过一个接口即可实现定制；
2. 可插拔的对象替换技术，不需要通过继承的方式；
3. 可插拔的预定义类缓存表，可以减小序列化的字节数组长度，提升常用类型的对象序列化性能；
4. 无须实现 java.io.Serializable 接口，即可实现 Java 序列化；
5. 通过缓存技术提升对象的序列化性能。

相比于前面介绍的两种编解码框架，JBoss Marshalling 更多是在 JBoss 内部使用，应用范围有限。

### 其它编解码框架
除了上述介绍的编解码框架和技术之外，比较常用的还有 MessagePack、kryo、hession 和 Json 等。